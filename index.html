<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cloud Native Gateway</title>
  <link href="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css" rel="stylesheet">
  <script src="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js"></script>
  <script src="lib/mapbox-gl-rtl-text.min.js"></script>
  <script src="https://unpkg.com/shpjs@4.0.4/dist/shp.js"></script>
  <script src="gdal3.js"></script>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --accent:        #5eead4;
      --accent-dim:    rgba(94,234,212,.13);
      --accent-border: rgba(94,234,212,.32);
      --purple:        #a78bfa;
      --bg:            #07090f;
      --panel:         #0c1119;
      --panel-2:       #111827;
      --panel-3:       #16202f;
      --border:        rgba(255,255,255,.07);
      --border-hi:     rgba(255,255,255,.14);
      --text:          #e8edf5;
      --muted:         #5a7090;
      --muted-2:       #8aa4c0;
      --red:           #f87171;
      --red-dim:       rgba(248,113,113,.12);
    }
    html, body { height: 100%; overflow: hidden; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      font-size: 14px;
    }

    /* ═══ SIDEBAR ═══════════════════════════════════════════ */
    .sidebar {
      width: 360px; flex-shrink: 0;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex; flex-direction: column;
      height: 100vh; overflow: hidden;
    }

    /* Header */
    .sidebar-head {
      padding: 18px 18px 15px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .wordmark { display: flex; align-items: center; gap: 11px; }
    .wordmark-icon {
      width: 34px; height: 34px;
      background: linear-gradient(135deg, var(--accent), var(--purple));
      border-radius: 9px;
      display: flex; align-items: center; justify-content: center; flex-shrink: 0;
    }
    .wordmark-icon svg { width: 17px; height: 17px; }
    .wordmark-text { font-size: 16px; font-weight: 700; letter-spacing: -.025em; }

    /* Upload */
    .upload-wrap { padding: 13px 13px 0; flex-shrink: 0; }
    .upload-zone {
      border: 1.5px dashed var(--border-hi);
      border-radius: 14px; padding: 20px 14px;
      text-align: center; cursor: pointer;
      transition: border-color .2s, background .2s;
      background: rgba(255,255,255,.018);
    }
    .upload-zone:hover, .upload-zone.dragover {
      border-color: var(--accent-border); background: var(--accent-dim);
    }
    .upload-zone input { display: none; }
    .uz-icon {
      width: 40px; height: 40px; margin: 0 auto 9px;
      border-radius: 12px; background: var(--accent-dim);
      border: 1px solid var(--accent-border);
      display: flex; align-items: center; justify-content: center;
    }
    .uz-icon svg { width: 18px; height: 18px; stroke: var(--accent); fill: none; stroke-width: 1.8; stroke-linecap: round; stroke-linejoin: round; }
    .uz-title { font-size: 14px; font-weight: 700; margin-bottom: 4px; }
    .uz-hint  { font-size: 12px; color: var(--muted); margin-bottom: 13px; }
    .uz-btn {
      display: inline-flex; align-items: center; gap: 6px;
      background: var(--accent); color: #060c14;
      font-size: 13px; font-weight: 700;
      border: none; border-radius: 20px; padding: 9px 20px;
      cursor: pointer; transition: opacity .15s, transform .15s;
    }
    .uz-btn:hover { opacity: .88; transform: translateY(-1px); }

    /* Progress */
    .proc-panel {
      margin: 10px 13px 0;
      background: var(--panel-2); border: 1px solid var(--border);
      border-radius: 12px; padding: 13px 15px; display: none; flex-shrink: 0;
    }
    .proc-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
    .proc-label { font-size: 13px; font-weight: 600; }
    .proc-pct   { font-size: 13px; color: var(--accent); font-weight: 700; font-variant-numeric: tabular-nums; }
    .proc-bar-track { height: 3px; background: var(--border); border-radius: 99px; overflow: hidden; margin-bottom: 7px; }
    .proc-bar-fill  { height: 100%; background: linear-gradient(90deg, var(--accent), var(--purple)); width: 0%; transition: width .25s ease; }
    .proc-file { font-size: 11px; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    /* Layers wrap — scrollable middle section */
    .layers-wrap { flex: 1; overflow-y: auto; padding: 0 13px 8px; margin-top: 8px; }
    .layers-wrap::-webkit-scrollbar { width: 4px; }
    .layers-wrap::-webkit-scrollbar-thumb { background: var(--border-hi); border-radius: 4px; }
    .layers-label {
      font-size: 11px; font-weight: 700; letter-spacing: .07em;
      text-transform: uppercase; color: var(--muted); padding: 5px 2px 8px;
    }

    /* ── Layer card ── */
    .layer-card {
      background: var(--panel-2); border: 1px solid var(--border);
      border-radius: 13px; margin-bottom: 8px; overflow: hidden;
      transition: border-color .15s;
    }
    .layer-card:hover { border-color: var(--border-hi); }
    .layer-card.style-open { border-color: var(--accent-border); }

    .layer-head { display: flex; align-items: center; gap: 9px; padding: 11px 12px; }
    .layer-dot { width: 11px; height: 11px; border-radius: 50%; flex-shrink: 0; box-shadow: 0 0 8px currentColor; }
    .layer-name-wrap { flex: 1; min-width: 0; }
    .layer-name { font-size: 13px; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .layer-geom { font-size: 11px; color: var(--muted); margin-top: 2px; }

    /* Action buttons — larger, labelled, colour-coded */
    .layer-actions { display: flex; gap: 4px; }
    .la-btn {
      height: 30px; padding: 0 9px;
      background: rgba(255,255,255,.05);
      border: 1px solid var(--border-hi);
      color: var(--muted-2);
      border-radius: 8px; cursor: pointer; font-size: 11px; font-weight: 600;
      display: flex; align-items: center; gap: 4px;
      transition: all .13s; white-space: nowrap;
    }
    .la-btn svg { width: 13px; height: 13px; stroke: currentColor; fill: none; stroke-width: 2.2; stroke-linecap: round; stroke-linejoin: round; flex-shrink: 0; }
    .la-btn:hover         { background: rgba(255,255,255,.1); color: var(--text); border-color: var(--border-hi); }
    .la-btn.style-btn:hover { background: rgba(94,234,212,.15); color: var(--accent); border-color: var(--accent-border); }
    .la-btn.style-active  { background: var(--accent-dim); color: var(--accent); border-color: var(--accent-border); }
    .la-btn.tog-btn:hover { background: rgba(167,139,250,.15); color: var(--purple); border-color: rgba(167,139,250,.3); }
    .la-btn.tog-off       { opacity: .45; }
    .la-btn.zoom-btn:hover{ background: rgba(96,165,250,.15); color: #60a5fa; border-color: rgba(96,165,250,.3); }
    .la-btn.del-btn:hover { background: var(--red-dim); color: var(--red); border-color: rgba(248,113,113,.3); }

    /* ── Style panel ── */
    .style-panel {
      display: none; padding: 2px 12px 12px;
      border-top: 1px solid var(--border); background: var(--panel-3);
    }
    .style-panel.open { display: block; }
    .sp-title { font-size: 11px; font-weight: 700; letter-spacing: .06em; text-transform: uppercase; color: var(--muted); padding: 10px 0 8px; }
    .style-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 7px 0; border-bottom: 1px solid var(--border); gap: 10px;
    }
    .style-row:last-child { border-bottom: none; }
    .style-label { font-size: 12px; font-weight: 600; color: var(--muted-2); white-space: nowrap; }
    .style-ctrl  { display: flex; align-items: center; gap: 7px; }

    .color-swatch {
      width: 26px; height: 26px; border-radius: 7px;
      border: 1.5px solid var(--border-hi); cursor: pointer;
      overflow: hidden; position: relative; flex-shrink: 0;
    }
    .color-swatch input[type=color] {
      position: absolute; inset: -4px; width: calc(100% + 8px); height: calc(100% + 8px);
      opacity: 0; cursor: pointer; border: none;
    }
    .range-slider {
      -webkit-appearance: none; width: 88px; height: 3px;
      border-radius: 99px; background: var(--border-hi); outline: none; cursor: pointer;
    }
    .range-slider::-webkit-slider-thumb {
      -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
      background: var(--accent); cursor: pointer; box-shadow: 0 0 6px rgba(94,234,212,.5);
    }
    .range-val { font-size: 11px; color: var(--muted-2); min-width: 34px; text-align: right; font-variant-numeric: tabular-nums; }
    .label-select {
      background: var(--panel); border: 1px solid var(--border-hi);
      border-radius: 7px; color: var(--text); font-size: 12px;
      padding: 5px 7px; cursor: pointer; max-width: 140px; outline: none;
    }
    .label-select:focus { border-color: var(--accent-border); }

    /* ── Export buttons ── */
    .layer-exports {
      display: grid; grid-template-columns: 1fr 1fr 1fr;
      gap: 5px; padding: 0 11px 11px;
    }
    .exp-btn {
      background: rgba(255,255,255,.04); border: 1px solid var(--border);
      border-radius: 8px; padding: 7px 4px;
      font-size: 11px; font-weight: 600; letter-spacing: .01em;
      color: var(--muted); cursor: pointer; text-align: center; transition: all .13s;
    }
    .exp-btn:hover { background: var(--accent-dim); border-color: var(--accent-border); color: var(--accent); }
    .exp-btn.wide { grid-column: span 3; font-size: 12px; padding: 8px; }

    /* ── Sidebar footer — Inclusive Map button ── */
    .sidebar-footer {
      padding: 10px 13px 14px; border-top: 1px solid var(--border); flex-shrink: 0; display: none;
    }
    .atlas-btn {
      display: flex; align-items: center; justify-content: center; gap: 8px;
      width: 100%; background: linear-gradient(135deg, rgba(94,234,212,.15), rgba(167,139,250,.12));
      border: 1px solid var(--accent-border); color: var(--accent);
      border-radius: 11px; padding: 11px; font-size: 13px; font-weight: 700;
      cursor: pointer; transition: all .18s; letter-spacing: .01em;
    }
    .atlas-btn:hover { background: linear-gradient(135deg, rgba(94,234,212,.25), rgba(167,139,250,.2)); transform: translateY(-1px); box-shadow: 0 4px 20px rgba(94,234,212,.15); }
    .atlas-btn svg { width: 16px; height: 16px; stroke: currentColor; fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }

    /* ═══ MAP ════════════════════════════════════════════════ */
    .map-wrap { flex: 1; position: relative; }
    #map { width: 100%; height: 100vh; }
    .map-badge {
      position: absolute; bottom: 28px; left: 16px; z-index: 10;
      background: rgba(7,9,15,.85); border: 1px solid var(--border-hi);
      border-radius: 20px; padding: 6px 16px;
      font-size: 12px; color: rgba(255,255,255,.5);
      backdrop-filter: blur(8px); pointer-events: none;
    }

    /* MapLibre popup */
    .maplibregl-popup-content {
      background: #0c1119 !important; border: 1px solid rgba(255,255,255,.11) !important;
      border-radius: 12px !important; padding: 0 !important;
      box-shadow: 0 14px 44px rgba(0,0,0,.65) !important;
      min-width: 210px; max-width: 310px;
    }
    .maplibregl-popup-tip { border-top-color: #0c1119 !important; border-bottom-color: #0c1119 !important; }
    .maplibregl-popup-close-button { color: rgba(255,255,255,.3) !important; font-size: 16px !important; padding: 8px 10px !important; }
    .pop-head { padding: 9px 32px 9px 13px; border-radius: 12px 12px 0 0; font-size: 12px; font-weight: 700; }
    .pop-table { width: 100%; border-collapse: collapse; }
    .pop-table tr { border-bottom: 1px solid rgba(255,255,255,.05); }
    .pop-table tr:last-child { border: none; }
    .pop-table td { padding: 5px 13px; font-size: 12px; line-height: 1.4; }
    .pop-table td:first-child { color: rgba(255,255,255,.38); width: 38%; }
    .pop-table td:last-child { color: var(--text); font-weight: 500; word-break: break-word; }
  </style>
</head>
<body>

<!-- ══════════════════════════ SIDEBAR ══════════════════════════ -->
<div class="sidebar">

  <div class="sidebar-head">
    <div class="wordmark">
      <div class="wordmark-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="#060c14" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:17px;height:17px">
          <circle cx="12" cy="12" r="10"/>
          <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10A15.3 15.3 0 0 1 8 12a15.3 15.3 0 0 1 4-10z"/>
        </svg>
      </div>
      <div class="wordmark-text">Cloud Native Gateway</div>
    </div>
  </div>

  <div class="upload-wrap">
    <div id="dropZone" class="upload-zone">
      <input id="fileInput" type="file" accept=".zip,.gpkg,.geojson,.json,.csv" multiple>
      <div class="uz-icon">
        <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
      </div>
      <div class="uz-title">Drop files here</div>
      <div class="uz-hint">Shapefile · GeoPackage · GeoJSON · CSV</div>
      <button class="uz-btn" id="browseButton" type="button">
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
        Choose Files
      </button>
    </div>
  </div>

  <div class="proc-panel" id="procPanel">
    <div class="proc-row">
      <span class="proc-label" id="procLabel">Processing…</span>
      <span class="proc-pct" id="procPct">0%</span>
    </div>
    <div class="proc-bar-track"><div class="proc-bar-fill" id="procBar"></div></div>
    <div class="proc-file" id="procFile">—</div>
  </div>

  <div class="layers-wrap" id="layersWrap" style="display:none">
    <div class="layers-label">Layers</div>
    <div id="layerCards"></div>
  </div>

  <!-- Inclusive Map export button at the bottom -->
  <div class="sidebar-footer" id="sidebarFooter">
    <button class="atlas-btn" onclick="exportInclusiveMap()">
      <svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
      Export Inclusive Map — All Layers
    </button>
  </div>
</div>

<!-- ══════════════════════════ MAP ══════════════════════════════ -->
<div class="map-wrap">
  <div id="map"></div>
  <div class="map-badge" id="mapBadge">No data loaded</div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// BASEMAP — Google Satellite + Labels + RTL plugin (local)
// ═══════════════════════════════════════════════════════════════
const OSM_STYLE = {
  version: 8,
  sources: {
    'satellite': {
      type: 'raster',
      tiles: ['https://mt0.google.com/vt?lyrs=y&x={x}&y={y}&z={z}'],
      tileSize: 256,
      attribution: '© Google'
    }
  },
  layers: [{ id: 'sat', type: 'raster', source: 'satellite' }]
};

maplibregl.setRTLTextPlugin('lib/mapbox-gl-rtl-text.min.js', false, e => console.warn('RTL:', e));

const map = new maplibregl.Map({
  container: 'map', style: OSM_STYLE, center: [20, 20], zoom: 2
});
map.addControl(new maplibregl.NavigationControl(), 'bottom-right');
map.addControl(new maplibregl.ScaleControl({ unit: 'metric' }), 'bottom-left');

// Add glyphs for text rendering (required for labels)
map.on('load', () => {
  if (!map.getStyle().glyphs) {
    map.setGlyphs('https://fonts.openmaptiles.org/{fontstack}/{range}.pbf');
  }
});

// ═══════════════════════
// STATE
// ═══════════════════════
const state = { layers: [], gdal: null, gdalAvailable: false };
const COLORS = ['#5eead4','#f472b6','#fb923c','#60a5fa','#a78bfa','#34d399','#facc15','#f87171'];

// ═══════════════════════
// UI REFS
// ═══════════════════════
const dropZone     = document.getElementById('dropZone');
const fileInput    = document.getElementById('fileInput');
const browseBtn    = document.getElementById('browseButton');
const procPanel    = document.getElementById('procPanel');
const procLabel    = document.getElementById('procLabel');
const procPct      = document.getElementById('procPct');
const procBar      = document.getElementById('procBar');
const procFile     = document.getElementById('procFile');
const mapBadge     = document.getElementById('mapBadge');
const layersWrap   = document.getElementById('layersWrap');
const layerCards   = document.getElementById('layerCards');
const sidebarFooter= document.getElementById('sidebarFooter');

// ═══════════════════════
// DRAG & DROP
// ═══════════════════════
['dragenter','dragover','dragleave','drop'].forEach(ev =>
  dropZone.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); }));
['dragenter','dragover'].forEach(ev => dropZone.addEventListener(ev, () => dropZone.classList.add('dragover')));
['dragleave','drop'].forEach(ev   => dropZone.addEventListener(ev, () => dropZone.classList.remove('dragover')));
dropZone.addEventListener('drop', e => { const f=Array.from(e.dataTransfer.files); if(f.length) processFiles(f); });
browseBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => { if(e.target.files.length) processFiles(Array.from(e.target.files)); });

// ═══════════════════════
// PROGRESS
// ═══════════════════════
function setProgress(pct, label, file) {
  procPanel.style.display = 'block';
  procPct.textContent = Math.round(pct) + '%';
  procBar.style.width = pct + '%';
  if (label !== null && label !== undefined) procLabel.textContent = label;
  if (file  !== null && file  !== undefined) procFile.textContent  = file;
}

// ═══════════════════════
// GDAL
// ═══════════════════════
async function initGDAL() {
  setProgress(5, 'Loading GDAL…', 'gdal3.js');
  let att = 0;
  while (typeof window.initGdalJs !== 'function' && att++ < 100)
    await new Promise(r => setTimeout(r, 100));
  if (typeof window.initGdalJs !== 'function') throw new Error('initGdalJs not found');
  setProgress(15, 'Initialising GDAL…', 'gdal3WebAssembly.wasm');
  const inst = await window.initGdalJs({ path: 'lib/package/', useWorker: false });
  if (!inst) throw new Error('null');
  state.gdal = typeof inst.open === 'function' ? inst : inst.GDAL3 ?? inst;
  state.gdalAvailable = true;
  setProgress(100, 'GDAL ready', '');
  setTimeout(() => { procPanel.style.display = 'none'; }, 900);
}

async function convertWithOgr2ogr(file) {
  const gdal   = state.gdal;
  const opened = await gdal.open(file);
  if (!opened?.datasets?.length)
    throw new Error('GDAL: ' + (opened?.errors?.map(e=>e.message).join(', ') || '?'));
  const ds     = opened.datasets[0];
  const result = await gdal.ogr2ogr(ds, ['-f','GeoJSON','-t_srs','EPSG:4326']);
  const text   = gdal.Module.FS.readFile(result.local, { encoding: 'utf8' });
  try { await gdal.close(ds); } catch(_) {}
  return JSON.parse(text);
}

// ═══════════════════════
// FILE PROCESSING
// ═══════════════════════
async function processFiles(files) {
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const base = (i / files.length) * 100, step = 100 / files.length;
    setProgress(base + step * .05, `File ${i+1} of ${files.length}`, file.name);
    try {
      const gj = await processSingleFile(file, p => setProgress(base + step * p / 100, null, null));
      addLayer(file.name.replace(/\.[^.]+$/, ''), gj);
    } catch(e) { console.error(file.name, e); }
    setProgress(base + step, null, null);
  }
  setProgress(100, 'Complete', '');
  updateBadge();
  // Auto-zoom AFTER map is ready
  if (map.isStyleLoaded()) { fitAllLayers(); }
  else { map.once('load', () => fitAllLayers()); }
  setTimeout(() => { procPanel.style.display = 'none'; }, 1400);
}

async function processSingleFile(file, onP) {
  const ext = file.name.split('.').pop().toLowerCase();
  let gj;
  if (ext === 'zip') {
    onP(20);
    if (state.gdalAvailable) {
      try { gj = await convertWithOgr2ogr(file); onP(90); }
      catch(e) { console.warn('GDAL→shp.js', e); }
    }
    if (!gj) {
      onP(30); const buf = await file.arrayBuffer(); onP(60);
      const res = await shp(buf); onP(90);
      gj = Array.isArray(res)
        ? { type:'FeatureCollection', features: res.flatMap(l=>l.features||[]) } : res;
    }
  } else if (ext === 'gpkg') {
    onP(20);
    if (!state.gdalAvailable) throw new Error('GDAL required for .gpkg');
    gj = await convertWithOgr2ogr(file); onP(90);
  } else if (ext === 'geojson' || ext === 'json') {
    onP(30); let p = JSON.parse(await file.text()); onP(80);
    if (p.type === 'Feature') p = { type:'FeatureCollection', features:[p] };
    gj = p; onP(90);
  } else if (ext === 'csv') {
    onP(30); gj = csvToGeoJSON(await file.text()); onP(90);
  } else throw new Error('Unsupported: .' + ext);
  if (!gj?.features?.length) throw new Error('No features in ' + file.name);
  return gj;
}

// ═══════════════════════════════════════════════════════════
// ADD LAYER — creates map source/layers + sidebar card
// ═══════════════════════════════════════════════════════════
function addLayer(name, geojson) {
  const idx      = state.layers.length;
  const color    = COLORS[idx % COLORS.length];
  const id       = 'lyr-' + idx;
  const geomType = geojson.features[0]?.geometry?.type || 'Unknown';
  const propKeys = geojson.features[0]?.properties ? Object.keys(geojson.features[0].properties) : [];

  // Default style object — holds all live style state
  const style = {
    fillColor:    color,
    fillOpacity:  0.35,
    lineColor:    color,
    lineWidth:    1.8,
    pointColor:   color,
    pointOpacity: 0.9,
    pointSize:    7,          // base radius at zoom 12
    labelField:   'none',
    labelMinZoom: 0           // zoom level at which labels appear
  };

  state.layers.push({ id, name, geojson, color, visible: true, geomType, style, propKeys });

  // Add map layers once style is loaded
  const doAdd = () => addMapLayer(id, geojson, style, geomType);
  map.isStyleLoaded() ? doAdd() : map.once('load', doAdd);

  layersWrap.style.display    = 'block';
  sidebarFooter.style.display = 'block';

  // (Label picker removed per user request)

  const isPolygon = !geomType.includes('Point') && !geomType.includes('Line');
  const isPoint   = geomType.includes('Point');
  const isLine    = geomType.includes('Line');

  const card = document.createElement('div');
  card.className = 'layer-card';
  card.id = 'card-' + id;

  card.innerHTML = `
    <div class="layer-head">
      <div class="layer-dot" id="dot-${id}" style="background:${color};color:${color}"></div>
      <div class="layer-name-wrap">
        <div class="layer-name" title="${escA(name)}">${escH(name)}</div>
        <div class="layer-geom">${geojson.features.length} features · ${geomType}</div>
      </div>
      <div class="layer-actions">
        <button class="la-btn style-btn" id="stylebtn-${id}" title="Style layer" onclick="toggleStylePanel('${id}')">
          <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M4.93 4.93a10 10 0 0 0 0 14.14"/></svg>
          Style
        </button>
        <button class="la-btn tog-btn" id="togbtn-${id}" title="Toggle visibility" onclick="toggleLayer('${id}')">
          <svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
        <button class="la-btn zoom-btn" title="Zoom to layer" onclick="zoomToLayer('${id}')">
          <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
        </button>
        <button class="la-btn del-btn" title="Remove layer" onclick="removeLayer('${id}')">
          <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6M14 11v6"/></svg>
        </button>
      </div>
    </div>

    <div class="style-panel" id="style-${id}">
      <div class="sp-title">Layer Style</div>

      ${isPolygon ? `
      <div class="style-row">
        <span class="style-label">Fill Color</span>
        <div class="style-ctrl">
          <div class="color-swatch" id="fillSwatch-${id}" style="background:${color}">
            <input type="color" value="${color}" oninput="updateFillColor('${id}',this.value)">
          </div>
        </div>
      </div>
      <div class="style-row">
        <span class="style-label">Fill Opacity</span>
        <div class="style-ctrl">
          <input type="range" class="range-slider" min="0" max="1" step=".05" value="0.35" oninput="updateFillOpacity('${id}',this.value)">
          <span class="range-val" id="fillOpVal-${id}">35%</span>
        </div>
      </div>
      <div class="style-row">
        <span class="style-label">Outline Color</span>
        <div class="style-ctrl">
          <div class="color-swatch" id="lineSwatch-${id}" style="background:${color}">
            <input type="color" value="${color}" oninput="updateLineColor('${id}',this.value)">
          </div>
        </div>
      </div>
      <div class="style-row">
        <span class="style-label">Outline Width</span>
        <div class="style-ctrl">
          <input type="range" class="range-slider" min="0" max="8" step=".5" value="1.8" oninput="updateLineWidth('${id}',this.value)">
          <span class="range-val" id="lineWVal-${id}">1.8px</span>
        </div>
      </div>` : isLine ? `
      <div class="style-row">
        <span class="style-label">Line Color</span>
        <div class="style-ctrl">
          <div class="color-swatch" id="lineSwatch-${id}" style="background:${color}">
            <input type="color" value="${color}" oninput="updateLineColor('${id}',this.value)">
          </div>
        </div>
      </div>
      <div class="style-row">
        <span class="style-label">Line Width</span>
        <div class="style-ctrl">
          <input type="range" class="range-slider" min="0.5" max="12" step=".5" value="2.5" oninput="updateLineWidth('${id}',this.value)">
          <span class="range-val" id="lineWVal-${id}">2.5px</span>
        </div>
      </div>` : `
      <div class="style-row">
        <span class="style-label">Point Color</span>
        <div class="style-ctrl">
          <div class="color-swatch" id="fillSwatch-${id}" style="background:${color}">
            <input type="color" value="${color}" oninput="updatePointColor('${id}',this.value)">
          </div>
        </div>
      </div>
      <div class="style-row">
        <span class="style-label">Point Size</span>
        <div class="style-ctrl">
          <input type="range" class="range-slider" min="2" max="24" step="1" value="7" oninput="updatePointSize('${id}',this.value)">
          <span class="range-val" id="ptSzVal-${id}">7px</span>
        </div>
      </div>
      <div class="style-row">
        <span class="style-label">Opacity</span>
        <div class="style-ctrl">
          <input type="range" class="range-slider" min="0" max="1" step=".05" value="0.9" oninput="updatePointOpacity('${id}',this.value)">
          <span class="range-val" id="fillOpVal-${id}">90%</span>
        </div>
      </div>`}

      <!-- Label controls removed -->
    </div>

    <div class="layer-exports">
      <button class="exp-btn" onclick="exportLayer('${id}','fgb')">FlatGeobuf</button>
      <button class="exp-btn" onclick="exportLayer('${id}','pmtiles')">PMTiles</button>
      <button class="exp-btn" onclick="exportLayer('${id}','parquet')">GeoParquet</button>
    </div>`;

  layerCards.appendChild(card);
}

// ═══════════════════════════════════════════════════════════
// ADD MAP LAYERS — uses unique IDs per layer, no ID conflicts
// ═══════════════════════════════════════════════════════════
function addMapLayer(id, geojson, style, geomType) {
  if (map.getSource(id)) return;   // guard: already added
  map.addSource(id, { type: 'geojson', data: geojson, generateId: true });

  const isPoint   = geomType.includes('Point');
  const isLine    = geomType.includes('Line');

  if (isPoint) {
    map.addLayer({ id: id+'-circle', type: 'circle', source: id, paint: {
      'circle-radius':       ['interpolate',['linear'],['zoom'], 2,2, 12,style.pointSize, 18,style.pointSize*1.8],
      'circle-color':        style.pointColor,
      'circle-opacity':      style.pointOpacity,
      'circle-stroke-width': 1.5,
      'circle-stroke-color': 'rgba(0,0,0,.35)'
    }});
  } else if (isLine) {
    map.addLayer({ id: id+'-line', type: 'line', source: id, paint: {
      'line-color':   style.lineColor,
      'line-width':   style.lineWidth,
      'line-opacity': 0.9
    }});
  } else {
    map.addLayer({ id: id+'-fill', type: 'fill', source: id, paint: {
      'fill-color':   style.fillColor,
      'fill-opacity': style.fillOpacity
    }});
    map.addLayer({ id: id+'-outline', type: 'line', source: id, paint: {
      'line-color': style.lineColor,
      'line-width': style.lineWidth
    }});
  }

  // Popup click target
  const clickId = isPoint ? id+'-circle' : isLine ? id+'-line' : id+'-fill';
  map.on('click', clickId, e => {
    const props   = e.features[0]?.properties || {};
    const nameKey = Object.keys(props).find(k => /name|label|title/i.test(k));
    const title   = nameKey ? String(props[nameKey]) : 'Feature';
    const rows    = Object.entries(props)
      .map(([k,v]) => `<tr><td>${escH(k)}</td><td>${escH(String(v)).substring(0,130)}</td></tr>`).join('');
    const c = style.fillColor || style.lineColor || style.pointColor;
    new maplibregl.Popup({ maxWidth: '310px', offset: 8 })
      .setLngLat(e.lngLat)
      .setHTML(`<div class="pop-head" style="background:${c}20;border-bottom:2px solid ${c}">${title}</div>
                <table class="pop-table">${rows}</table><div style="height:4px"></div>`)
      .addTo(map);
  });
  map.on('mouseenter', clickId, () => map.getCanvas().style.cursor = 'pointer');
  map.on('mouseleave', clickId, () => map.getCanvas().style.cursor = '');
}

// ═══════════════════════
// STYLE PANEL TOGGLE
// ═══════════════════════
function toggleStylePanel(id) {
  const panel = document.getElementById('style-'+id);
  const btn   = document.getElementById('stylebtn-'+id);
  const card  = document.getElementById('card-'+id);
  const open  = panel.classList.toggle('open');
  btn.classList.toggle('style-active', open);
  card.classList.toggle('style-open', open);
}

// ═══════════════════════
// LIVE STYLE UPDATES
// ═══════════════════════
function getLyr(id) { return state.layers.find(l => l.id === id); }

function updateFillColor(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.fillColor = val;
  document.getElementById('fillSwatch-'+id).style.background = val;
  syncDot(id);
  if (map.getLayer(id+'-fill')) map.setPaintProperty(id+'-fill', 'fill-color', val);
}
function updateFillOpacity(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.fillOpacity = +val;
  setValEl('fillOpVal-'+id, Math.round(val*100)+'%');
  if (map.getLayer(id+'-fill')) map.setPaintProperty(id+'-fill', 'fill-opacity', +val);
}
function updateLineColor(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.lineColor = val;
  const sw = document.getElementById('lineSwatch-'+id);
  if (sw) sw.style.background = val;
  if (!l.geomType.includes('Point')) syncDot(id);
  const lineLayerId = l.geomType.includes('Line') ? id+'-line' : id+'-outline';
  if (map.getLayer(lineLayerId)) map.setPaintProperty(lineLayerId, 'line-color', val);
}
function updateLineWidth(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.lineWidth = +val;
  setValEl('lineWVal-'+id, parseFloat(val).toFixed(1)+'px');
  const lineLayerId = l.geomType.includes('Line') ? id+'-line' : id+'-outline';
  if (map.getLayer(lineLayerId)) map.setPaintProperty(lineLayerId, 'line-width', +val);
}
function updatePointColor(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.pointColor = val;
  document.getElementById('fillSwatch-'+id).style.background = val;
  syncDot(id);
  if (map.getLayer(id+'-circle')) map.setPaintProperty(id+'-circle', 'circle-color', val);
}
function updatePointSize(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.pointSize = +val;
  setValEl('ptSzVal-'+id, val+'px');
  if (map.getLayer(id+'-circle')) map.setPaintProperty(id+'-circle', 'circle-radius',
    ['interpolate',['linear'],['zoom'], 2,2, 12,+val, 18,+val*1.8]);
}
function updatePointOpacity(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.pointOpacity = +val;
  setValEl('fillOpVal-'+id, Math.round(val*100)+'%');
  if (map.getLayer(id+'-circle')) map.setPaintProperty(id+'-circle', 'circle-opacity', +val);
}
function updateLabel(id, field) {
  const l = getLyr(id); if (!l) return;
  l.style.labelField = field;
  // Show/hide zoom row
  const zr = document.getElementById('labelZoomRow-'+id);
  if (zr) zr.style.display = field === 'none' ? 'none' : 'flex';
  // Remove existing label layer
  if (map.getLayer(id+'-label')) map.removeLayer(id+'-label');
  if (field === 'none') return;
  addLabelLayer(id, field, l.style.labelMinZoom);
}
function updateLabelMinZoom(id, val) {
  const l = getLyr(id); if (!l) return;
  l.style.labelMinZoom = +val;
  setValEl('lblZoomVal-'+id, val);
  if (map.getLayer(id+'-label')) map.removeLayer(id+'-label');
  if (l.style.labelField !== 'none') addLabelLayer(id, l.style.labelField, +val);
}
function addLabelLayer(id, field, minZoom) {
  map.addLayer({
    id: id+'-label', type: 'symbol', source: id,
    minzoom: minZoom || 0,
    layout: {
      'text-field':    ['to-string', ['get', field]],
      'text-font':     ['Noto Sans Regular'],
      'text-size':     13,
      'text-anchor':   'bottom',
      'text-offset':   [0, -0.5],
      'text-allow-overlap': false
    },
    paint: {
      'text-color':       '#ffffff',
      'text-halo-color':  'rgba(0,0,0,.75)',
      'text-halo-width':  1.5
    }
  });
}
function syncDot(id) {
  const l = getLyr(id); if (!l) return;
  const c = l.geomType.includes('Point') ? l.style.pointColor : l.style.fillColor || l.style.lineColor;
  const dot = document.getElementById('dot-'+id);
  if (dot) { dot.style.background = c; dot.style.color = c; }
  l.color = c;
}
function setValEl(id, val) { const el=document.getElementById(id); if(el) el.textContent=val; }

// ═══════════════════════
// LAYER CONTROLS
// ═══════════════════════
function toggleLayer(id) {
  const l = getLyr(id); if (!l) return;
  l.visible = !l.visible;
  const vis = l.visible ? 'visible' : 'none';
  [id+'-fill', id+'-outline', id+'-circle', id+'-line', id+'-label'].forEach(lid => {
    if (map.getLayer(lid)) map.setLayoutProperty(lid, 'visibility', vis);
  });
  const card  = document.getElementById('card-'+id);
  const togBtn= document.getElementById('togbtn-'+id);
  if (card)   card.style.opacity  = l.visible ? '1' : '.55';
  if (togBtn) togBtn.classList.toggle('tog-off', !l.visible);
}

function zoomToLayer(id) {
  const l = getLyr(id); if (!l) return;
  let mn=[Infinity,Infinity], mx=[-Infinity,-Infinity];
  l.geojson.features.forEach(f => extractCoords(f.geometry).forEach(([lng,lat]) => {
    if (!isFinite(lng)||!isFinite(lat)) return;
    if (lng<mn[0]) mn[0]=lng; if (lat<mn[1]) mn[1]=lat;
    if (lng>mx[0]) mx[0]=lng; if (lat>mx[1]) mx[1]=lat;
  }));
  if (mn[0] !== Infinity) map.fitBounds([mn,mx], { padding:70, duration:800, maxZoom:18 });
}

function removeLayer(id) {
  [id+'-fill', id+'-outline', id+'-circle', id+'-line', id+'-label'].forEach(lid => {
    if (map.getLayer(lid)) map.removeLayer(lid);
  });
  if (map.getSource(id)) map.removeSource(id);
  state.layers = state.layers.filter(l => l.id !== id);
  document.getElementById('card-'+id)?.remove();
  if (!state.layers.length) {
    layersWrap.style.display     = 'none';
    sidebarFooter.style.display  = 'none';
    mapBadge.textContent         = 'No data loaded';
  } else updateBadge();
}

// ═══════════════════════
// EXPORT
// ═══════════════════════
function exportLayer(id, format) {
  const l = getLyr(id); if (!l) return;
  let content, ext, mime;
  if (format === 'html') {
    content = generateSingleMap(l);
    ext = 'html'; mime = 'text/html';
  } else {
    content = JSON.stringify({ format, data: l.geojson }, null, 2);
    ext = format; mime = 'application/octet-stream';
  }
  dlFile(content, l.name + '.' + ext, mime);
}

function exportInclusiveMap() {
  if (!state.layers.length) return;
  dlFile(generateInclusiveMap(state.layers), 'inclusive_map.html', 'text/html');
}

function dlFile(content, name, mime) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([content], { type: mime }));
  a.download = name;
  a.click();
}

// ═══════════════════════
// HELPERS
// ═══════════════════════
function fitAllLayers() {
  if (!state.layers.length) return;
  let mn=[Infinity,Infinity], mx=[-Infinity,-Infinity];
  state.layers.forEach(l => l.geojson.features.forEach(f =>
    extractCoords(f.geometry).forEach(([lng,lat]) => {
      if (!isFinite(lng)||!isFinite(lat)) return;
      if (lng<mn[0]) mn[0]=lng; if (lat<mn[1]) mn[1]=lat;
      if (lng>mx[0]) mx[0]=lng; if (lat>mx[1]) mx[1]=lat;
    })));
  if (mn[0] !== Infinity) map.fitBounds([mn,mx], { padding:70, duration:900, maxZoom:18 });
}

function updateBadge() {
  const total = state.layers.reduce((s,l) => s+l.geojson.features.length, 0);
  mapBadge.textContent = total + ' features · ' + state.layers.length + ' layer' + (state.layers.length>1?'s':'');
}

function extractCoords(g) {
  if (!g) return [];
  try {
    if (g.type==='Point')           return [g.coordinates];
    if (g.type==='MultiPoint'||g.type==='LineString') return g.coordinates;
    if (g.type==='Polygon')         return g.coordinates[0]||[];
    if (g.type==='MultiLineString') return g.coordinates.flat();
    if (g.type==='MultiPolygon')    return g.coordinates.flat(2);
  } catch(_) {}
  return [];
}

function escH(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function escA(s) { return String(s).replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

function csvToGeoJSON(csv) {
  const lines = csv.split('\n').filter(l=>l.trim());
  const hdrs  = lines[0].split(',').map(h=>h.trim());
  let latC=-1, lngC=-1;
  hdrs.forEach((h,i) => {
    const lh = h.toLowerCase();
    if (/^lat(itude)?$|^y$/.test(lh)) latC=i;
    if (/^lo?ng?(itude)?$|^x$/.test(lh)) lngC=i;
  });
  if (latC<0||lngC<0) throw new Error('CSV: no lat/lon columns');
  const features = [];
  for (let i=1;i<lines.length;i++) {
    const v = lines[i].split(',').map(s=>s.trim());
    const lat=parseFloat(v[latC]), lng=parseFloat(v[lngC]);
    if (!isNaN(lat)&&!isNaN(lng)) {
      const props={};
      hdrs.forEach((h,j) => { if(j!==latC&&j!==lngC) props[h]=v[j]; });
      features.push({ type:'Feature', geometry:{ type:'Point', coordinates:[lng,lat] }, properties:props });
    }
  }
  return { type:'FeatureCollection', features };
}

// ═══════════════════════════════════════════════════════════════════
// GENERATE INCLUSIVE MAP — all layers in a single map with beautiful basemap
// ═══════════════════════════════════════════════════════════════════
function generateInclusiveMap(layers) {
  const totalFt = layers.reduce((s,l)=>s+l.geojson.features.length,0);
  
  // Prepare layer data with styles
  const layersData = layers.map((l, i) => ({
    id: `layer-${i}`,
    name: l.name,
    geojson: l.geojson,
    style: l.style,
    geomType: l.geomType,
    visible: l.visible
  }));

  const layersJS = JSON.stringify(layersData).replace(/</g, '\\u003C');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Inclusive Map — ${layers.length} Layers</title>
  <link href="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css" rel="stylesheet">
  <script src="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js"><\/script>
  <script src="https://unpkg.com/@mapbox/mapbox-gl-rtl-text/mapbox-gl-rtl-text.min.js"><\/script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #07090f;
      overflow: hidden;
    }
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      height: 100%;
    }
    #controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10;
      background: rgba(12, 17, 25, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 12px;
      max-width: 280px;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
      color: #e8edf5;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    #controls h2 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      color: #a78bfa;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls h2 span {
      font-size: 12px;
      color: #5a7090;
      font-weight: normal;
    }
    .layer-item {
      margin-bottom: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .layer-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .layer-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      box-shadow: 0 0 8px currentColor;
    }
    .layer-name {
      flex: 1;
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .layer-stats {
      font-size: 10px;
      color: #5a7090;
    }
    .layer-toggle {
      width: 28px;
      height: 22px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px;
      color: #8aa4c0;
      cursor: pointer;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .layer-toggle:hover {
      background: rgba(94,234,212,0.15);
      border-color: rgba(94,234,212,0.3);
      color: #5eead4;
    }
    #badge {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(7,9,15,0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 6px 16px;
      font-size: 12px;
      color: rgba(255,255,255,0.5);
      backdrop-filter: blur(8px);
      pointer-events: none;
    }
    .maplibregl-popup-content {
      background: #0c1119 !important;
      border: 1px solid rgba(255,255,255,0.11) !important;
      border-radius: 12px !important;
      padding: 0 !important;
      box-shadow: 0 14px 44px rgba(0,0,0,0.65) !important;
      min-width: 210px;
      max-width: 310px;
    }
    .maplibregl-popup-tip {
      border-top-color: #0c1119 !important;
      border-bottom-color: #0c1119 !important;
    }
    .maplibregl-popup-close-button {
      color: rgba(255,255,255,0.3) !important;
      font-size: 16px !important;
      padding: 8px 10px !important;
    }
    .pop-head {
      padding: 9px 32px 9px 13px;
      border-radius: 12px 12px 0 0;
      font-size: 12px;
      font-weight: 700;
    }
    .pop-table {
      width: 100%;
      border-collapse: collapse;
    }
    .pop-table tr {
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .pop-table tr:last-child {
      border: none;
    }
    .pop-table td {
      padding: 5px 13px;
      font-size: 12px;
      line-height: 1.4;
    }
    .pop-table td:first-child {
      color: rgba(255,255,255,0.38);
      width: 38%;
    }
    .pop-table td:last-child {
      color: #e8edf5;
      font-weight: 500;
      word-break: break-word;
    }
    .zoom-btn {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px;
      padding: 2px 8px;
      font-size: 10px;
      color: #8aa4c0;
      cursor: pointer;
      margin-left: 4px;
    }
    .zoom-btn:hover {
      background: rgba(96,165,250,0.15);
      color: #60a5fa;
      border-color: rgba(96,165,250,0.3);
    }
    ::-webkit-scrollbar {
      width: 4px;
    }
    ::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <div id="controls">
    <h2>
      Inclusive Map
      <span>${layers.length} layer${layers.length > 1 ? 's' : ''} · ${totalFt} features</span>
    </h2>
    <div id="layer-list"></div>
  </div>
  
  <div id="badge">Click any feature for details</div>

  <script>
    maplibregl.setRTLTextPlugin('lib/mapbox-gl-rtl-text.min.js', false, e => console.warn('RTL:', e));
    
    // Basemap — Google Satellite + Labels
    const OSM_STYLE = {
      version: 8,
      sources: {
        'satellite': {
          type: 'raster',
          tiles: ['https://mt0.google.com/vt?lyrs=y&x={x}&y={y}&z={z}'],
          tileSize: 256,
          attribution: '© Google'
        }
      },
      layers: [{ id: 'sat', type: 'raster', source: 'satellite' }]
    };

    const layers = ${layersJS};
    
    const map = new maplibregl.Map({
      container: 'map',
      style: OSM_STYLE,
      center: [20, 20],
      zoom: 2
    });
    
    map.addControl(new maplibregl.NavigationControl(), 'bottom-right');
    map.addControl(new maplibregl.ScaleControl({ unit: 'metric' }), 'bottom-left');

    // Add glyphs for labels
    map.on('load', () => {
      if (!map.getStyle().glyphs) {
        map.setGlyphs('https://fonts.openmaptiles.org/{fontstack}/{range}.pbf');
      }
      
      // Add all layers
      layers.forEach(layer => {
        addLayerToMap(layer);
      });
      
      // Build layer list UI
      buildLayerList();
      
      // Fit bounds to all layers
      fitAllLayers();
    });

    function addLayerToMap(layer) {
      const id = layer.id;
      const style = layer.style;
      const geomType = layer.geomType;
      
      map.addSource(id, {
        type: 'geojson',
        data: layer.geojson,
        generateId: true
      });

      const isPoint = geomType.includes('Point');
      const isLine = geomType.includes('Line');

      if (isPoint) {
        map.addLayer({
          id: id + '-circle',
          type: 'circle',
          source: id,
          paint: {
            'circle-radius': ['interpolate', ['linear'], ['zoom'], 2, 2, 12, style.pointSize || 7, 18, (style.pointSize || 7) * 1.8],
            'circle-color': style.pointColor,
            'circle-opacity': style.pointOpacity || 0.9,
            'circle-stroke-width': 1.5,
            'circle-stroke-color': 'rgba(0,0,0,0.35)'
          }
        });
      } else if (isLine) {
        map.addLayer({
          id: id + '-line',
          type: 'line',
          source: id,
          paint: {
            'line-color': style.lineColor,
            'line-width': style.lineWidth || 2.5,
            'line-opacity': 0.9
          }
        });
      } else {
        map.addLayer({
          id: id + '-fill',
          type: 'fill',
          source: id,
          paint: {
            'fill-color': style.fillColor,
            'fill-opacity': style.fillOpacity || 0.35
          }
        });
        map.addLayer({
          id: id + '-outline',
          type: 'line',
          source: id,
          paint: {
            'line-color': style.lineColor,
            'line-width': style.lineWidth || 1.8
          }
        });
      }

      // Add labels if configured
      if (style.labelField && style.labelField !== 'none') {
        map.addLayer({
          id: id + '-label',
          type: 'symbol',
          source: id,
          minzoom: style.labelMinZoom || 0,
          layout: {
            'text-field': ['to-string', ['get', style.labelField]],
            'text-font': ['Noto Sans Regular'],
            'text-size': 13,
            'text-anchor': 'bottom',
            'text-offset': [0, -0.5],
            'text-allow-overlap': false
          },
          paint: {
            'text-color': '#ffffff',
            'text-halo-color': 'rgba(0,0,0,0.75)',
            'text-halo-width': 1.5
          }
        });
      }

      // Setup popup
      const clickId = isPoint ? id + '-circle' : isLine ? id + '-line' : id + '-fill';
      const color = style.fillColor || style.lineColor || style.pointColor;
      
      map.on('click', clickId, (e) => {
        const props = e.features[0]?.properties || {};
        const nameKey = Object.keys(props).find(k => /name|label|title/i.test(k));
        const title = nameKey ? String(props[nameKey]) : 'Feature';
        const rows = Object.entries(props)
          .map(([k, v]) => '<tr><td>' + k + '</td><td>' + String(v).substring(0, 130) + '</td></tr>')
          .join('');
        
        new maplibregl.Popup({ maxWidth: '310px', offset: 8 })
          .setLngLat(e.lngLat)
          .setHTML(
            '<div class="pop-head" style="background:' + color + '20;border-bottom:2px solid ' + color + '">' + title + '</div>' +
            '<table class="pop-table">' + rows + '</table><div style="height:4px"></div>'
          )
          .addTo(map);
      });
      
      map.on('mouseenter', clickId, () => { map.getCanvas().style.cursor = 'pointer'; });
      map.on('mouseleave', clickId, () => { map.getCanvas().style.cursor = ''; });
    }

    function buildLayerList() {
      const list = document.getElementById('layer-list');
      list.innerHTML = '';
      
      layers.forEach((layer, idx) => {
        const color = layer.style.fillColor || layer.style.lineColor || layer.style.pointColor;
        const item = document.createElement('div');
        item.className = 'layer-item';
        item.innerHTML = 
          '<div class="layer-header">' +
            '<div class="layer-dot" style="background:' + color + ';color:' + color + '"></div>' +
            '<div class="layer-name" title="' + layer.name + '">' + layer.name + '</div>' +
            '<button class="layer-toggle" onclick="toggleLayer(\\'' + layer.id + '\\')">👁️</button>' +
            '<button class="zoom-btn" onclick="zoomToLayer(\\'' + layer.id + '\\')">⊕</button>' +
          '</div>' +
          '<div class="layer-stats">' + layer.geojson.features.length + ' features · ' + layer.geomType + '</div>';
        list.appendChild(item);
      });
    }

    window.toggleLayer = function(id) {
      const layer = layers.find(l => l.id === id);
      if (!layer) return;
      
      const vis = layer.visible ? 'none' : 'visible';
      layer.visible = !layer.visible;
      
      ['-fill', '-outline', '-circle', '-line', '-label'].forEach(suffix => {
        const lid = id + suffix;
        if (map.getLayer(lid)) {
          map.setLayoutProperty(lid, 'visibility', vis === 'none' ? 'none' : 'visible');
        }
      });
      
      // Update button appearance
      buildLayerList();
    };

    window.zoomToLayer = function(id) {
      const layer = layers.find(l => l.id === id);
      if (!layer) return;
      
      let mn = [Infinity, Infinity];
      let mx = [-Infinity, -Infinity];
      
      function extractCoords(g) {
        if (!g) return [];
        try {
          if (g.type === 'Point') return [g.coordinates];
          if (g.type === 'MultiPoint' || g.type === 'LineString') return g.coordinates;
          if (g.type === 'Polygon') return g.coordinates[0] || [];
          if (g.type === 'MultiLineString') return g.coordinates.flat();
          if (g.type === 'MultiPolygon') return g.coordinates.flat(2);
        } catch(_) {}
        return [];
      }
      
      layer.geojson.features.forEach(f => {
        extractCoords(f.geometry).forEach(([lng, lat]) => {
          if (!isFinite(lng) || !isFinite(lat)) return;
          if (lng < mn[0]) mn[0] = lng;
          if (lat < mn[1]) mn[1] = lat;
          if (lng > mx[0]) mx[0] = lng;
          if (lat > mx[1]) mx[1] = lat;
        });
      });
      
      if (mn[0] !== Infinity) {
        map.fitBounds([mn, mx], { padding: 70, duration: 800, maxZoom: 18 });
      }
    };

    function fitAllLayers() {
      let mn = [Infinity, Infinity];
      let mx = [-Infinity, -Infinity];
      
      layers.forEach(layer => {
        layer.geojson.features.forEach(f => {
          extractCoords(f.geometry).forEach(([lng, lat]) => {
            if (!isFinite(lng) || !isFinite(lat)) return;
            if (lng < mn[0]) mn[0] = lng;
            if (lat < mn[1]) mn[1] = lat;
            if (lng > mx[0]) mx[0] = lng;
            if (lat > mx[1]) mx[1] = lat;
          });
        });
      });
      
      if (mn[0] !== Infinity) {
        map.fitBounds([mn, mx], { padding: 70, duration: 900, maxZoom: 18 });
      }
    }
    
    function extractCoords(g) {
      if (!g) return [];
      try {
        if (g.type === 'Point') return [g.coordinates];
        if (g.type === 'MultiPoint' || g.type === 'LineString') return g.coordinates;
        if (g.type === 'Polygon') return g.coordinates[0] || [];
        if (g.type === 'MultiLineString') return g.coordinates.flat();
        if (g.type === 'MultiPolygon') return g.coordinates.flat(2);
      } catch(_) {}
      return [];
    }
  <\/script>
</body>
</html>`;
}

// ═══════════════════════
// INIT
// ═══════════════════════
(async () => {
  try { await initGDAL(); }
  catch(e) { console.error('GDAL:', e); procPanel.style.display = 'none'; }
})();
</script>
</body>
</html>